---
title: 16S sequencing
---

## Presentation on the 16S sequencing technique

The most commonly used amplicon based technique in metagenomics is the targeted sequencing of certain variable regions of the 16S ribosomal RNA gene in bacterial genomes. The presentation will give a short introduction to the technology, while the practical session will go through each step of the analysis process. During the practicals, you will learn about the analysis principles and will have deep understanding on the benefits and caveats of the 16S-sequencing technique.

The presentation is accessible on Google Slides on the [following link](https://docs.google.com/presentation/d/1Hel01_xsi1ZH-HbSw7jxEGvy4RDpaefFEykcaaygilc/edit?usp=sharing).

::: {.callout-tip}
#### Key points

- 16S amplicon sequencing is the quickest and cheapest method to get community composition information from complex microbial samples.
- Sequence context (primer recognition sequence and sequence composition) may introduce abundance bias to the analysis.
- Sensitivity is usually better than shotgun metagenomics
- Resolution can reach species level but rarely to strain level
- Analysis can be done in `R` / `RStudio` using gold standard pipelines and analysis tools, complemented by extensive reference databases.
:::



## 16S Sequencing practical

During the practical you will analyse the data coming from a pilot study that was aimed to compare two animal facilities (mice faecal samples). Using the results you will be able to investigate the within and between grou variance and will be able to infer biologically relevant decisions.

### Preparing the environment

The base `R` installation is not providing the necessary functions for 16S amplicon sequencing and data analysis, we need to load in the required libraries for our analysis. The `dada2` package provides the functions for the data pre-processing and analysis, the `Biostrings` package helps in sequence data manipulation, the `phyloseq` package provides functions for post-processing (e.g., composition comparison) and finally we create our plots and graphs with the help of the `ggplot2` package. The last line sets the default plot theme to a simple black and white style.

```r
library("dada2")
library("phyloseq")
library("Biostrings")
library("ggplot2")
theme_set(theme_bw())
```

### Data import and sample organisation

In the first line we define the path to our data folder, followed by reading the list of files for forward and reverse sequencing reads. Finally we extract the sample names from the forward file names.

```r
path <- "FIX/ME"
fnFs <- sort(list.files(path, pattern="_1_sequence.txt.gz", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_2_sequence.txt.gz", full.names = TRUE))
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 6)

```

::: {.callout-exercise}
#### Fix the base path
{{< level 1 >}}
Use the graphical user interface file explorer or the command line to explore the filesystem and find the 16S analysis folder (TODO folder name). Replace the `FIX/ME` string with the full or relative (to your home) path to the `00_DATA` folder.

::: {.callout-answer}
TODO
:::
:::

### Data pre-processing

The first step during the 16S data pre-processing is the inspection of the raw sequencing read qualities and perform trimming and filtering accordingly. The `plotQualityProfile()`
function (from the `dada2` package) provides an overview of the read qualities in single or multiple input file(s).

```r
plotQualityProfile(fnFs[1:3])
plotQualityProfile(fnRs[1:3])
```

::: {.callout-exercise}
#### Plot 3 random input files
{{< level 2 >}}
The provided code will always read in the first three files (as were listed alphabetically in the data folder), selecting the first 3 elements of the `fnFs` and `fnRs` vector. Modify the code by utilising the `sample()` function to select 3 random input file names from the same two vectors. This way you are not constrain your inspection to the same three files, if you re-run the command, you can check a diiferent set of 3 random samples.

::: {.callout-answer}
The `sample()` function needs two arguments, a vector (in our case the `fnFs` and `fnRs` variables with file names) and the number of random sampled elements.
```r
plotQualityProfile(sample(fnFs, 3))
```
:::
:::

::: {.callout-tip}
Use the `?plotQualityProfile` command in the R console to read more about the function. You will find the detailed description of the output plot in the "Details" section of the help page.
:::

The next commands will define new file names for the filtered raw data and finally perform the data filtering itself. Please use the `?filterAndTrim` command to get more information onthe filtering function arguments.

```r
filtFs <- file.path(path, "filtered", paste0(sample.names, "_1_filt.sequence.txt.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_2_filt.sequence.txt.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(250,250),
                     maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
                     compress=TRUE, multithread=TRUE)
```

::: {.callout-exercise}
#### Set the truncation length
{{< level 2 >}}
The `truncLen` argument of the function defines the lengths (first number for forward, second number for reverse reads) we plan to keep from raw reads. The length has to be set by checking the previously generated quality plots by aiming to keep only high quality regions.

::: {.callout-answer}
The forward reads are usually high quality along the full sequence, except the last few nucleotides, so we can keep almost the full length (usually we cut 10 nucleotides from the end). The reverse sequencing reads very often have a point where the quality distribution crashes (common in illumina sequencing), you need to cut more off from the end.
```r
truncLen=c(240,160)
```
:::
:::

You can take a quick look at the amount of filtering has been done. If you notice significant drop in the number of reads carried forward, you may want to check the QC graphs and parameters given to the `filterAndTrim()` function.

```r
head(out)
```


